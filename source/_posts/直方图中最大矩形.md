---
title: 直方图中最大矩形
top: false
cover: false
toc: true
mathjax: true
date: 2019-08-11 21:09:02
password:
summary: 直方图是由在公共基线处对齐的一系列矩形组成的多边形。
tags: 单调堆
categories: 算法
---

#### 题目
直方图是由在公共基线处对齐的一系列矩形组成的多边形。

矩形具有相等的宽度，但可以具有不同的高度。

例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图
矩形的宽度都为1：
![图1](1.jpg)
通常，直方图用于表示离散分布，例如，文本中字符的频率。

现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。

图例右图显示了所描绘直方图的最大对齐矩形。
#### 输入格式
输入包含几个测试用例。

每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。

然后跟随n个整数h1，…，hn。

这些数字以从左到右的顺序表示直方图的各个矩形的高度。

每个矩形的宽度为1。

同行数字用空格隔开。

当输入用例为n=0时，结束输入，且该用例不用考虑。

#### 输出格式
对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。

每个数据占一行。

请注意，此矩形必须在公共基线处对齐。

#### 数据范围
1≤n≤100000,
0≤hi≤1000000000
#### 输入样例：

    7 2 1 4 5 1 3 3
    4 1000 1000 1000 1000
    0

#### 输出样例：

    8
    4000
#### 分析

 - 对于这个题，我们可以暴力枚举，先枚举每个位置，然后找到这个位置前面第一个小于他的位置再加1，和后面第一个小于他的位置再减1。
 - 那么这个区域内的可以形成一个(r-l+1)这么宽，当前枚举位置这么高的矩形，并且这个矩形是以当前枚举这个位置区域以他的高度为高最大的矩形。所以当我们枚举完所有位置时，并每次更新最大值，答案就出来了。
 - 但是如果暴力向前寻找第一个小于他的位置，这样时间会很大，所以我们要找下规律，我们发现，当假设i<j,如果有h[i]>h[j],那么后面枚举每个位置的时候，找到的第一个小于他的都不会是h[i]，因为对于h[j]他不是最小的，而且比j靠前。所以我们h[i]对于后面的查找没有用。所以有一点单调递增的性质，我们可以用单调栈来处理。
 - 对于每个当前值，假如栈顶的值大于当前值，那么就弹出，知道小于当前值，那么这个就是我们要找的值，更新结果以后，将当前值加入栈。
 - 具体实现见代码。


#### 代码
 

```
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;
typedef long long ll;
const int N=100005;

int ft[N],rt[N];//存i这个点大于等于i的最左边和最右边的下标 
pair<int,ll> opt[N];
int main()
{
	int n,maxn=0;
	while(cin>>n&&n){
		for(int i=1;i<=n;i++){
			cin>>opt[i].second;
			opt[i].first=i;
		}
		
		stack<pair<int,int> > s1;//维护左边区域的栈 
		s1.push({0,-1});
		for(int i=1;i<=n;i++){ 
			while(s1.top().second>=opt[i].second){//假如比当前值小，弹出 
				s1.pop();
			}
			ft[i]=s1.top().first+1;//更新值 
			s1.push(opt[i]);
		}
	
		stack<pair<int,int> > s2;//维护右边区域的栈 
		s2.push({n+1,-1});
		for(int i=n;i>=1;i--){
			while(s2.top().second>=opt[i].second ){//假如比当前值小，弹出
				s2.pop();
			}
			rt[i]=s2.top().first-1;//更新值
			s2.push(opt[i]);
		}
		
		ll ans=0;
		for(int i=1;i<=n;i++){
			ans=max(ans,(rt[i]-ft[i]+1)*opt[i].second);//s=(r-l+1)*h; 
		}
		cout<<ans<<endl;
	}
	return 0;
}

```

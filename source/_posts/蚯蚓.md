---
title: 蚯蚓
top: false
cover: false
toc: true
mathjax: true
date: 2019-08-13 13:14:35
password:
summary: 蛐蛐国最近蚯蚓成灾了！
tags: 单调堆
categories: 算法
---

#### 题目
蛐蛐国最近蚯蚓成灾了！

隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 n 只蚯蚓，第 i 只蚯蚓的长度为 ai ，所有蚯蚓的长度都是非负整数，即可能存在长度为0的蚯蚓。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只，将其切成两段。

若有多只最长的，则任选一只。

神刀手切开蚯蚓的位置由有理数 p 决定。

一只长度为 x 的蚯蚓会被切成两只长度分别为 ⌊px⌋ 和 x−⌊px⌋ 的蚯蚓。

特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。

此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加一个非负整数 q 。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。

蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 m 秒才能到来。

蛐蛐国王希望知道这 m 秒内的战况。

具体来说，他希望知道：

m 秒内，每一秒被切断的蚯蚓被切断前的长度，共有 m 个数。
m 秒后，所有蚯蚓的长度，共有 n+m 个数。
#### 输入格式
第一行包含六个整数 n,m,q,u,v,t，其中：n,m,q 的意义参考题目描述；u,v,t 均为正整数；你需要自己计算 p=u/v（保证 0<u<v）；t 是输出参数，其含义将会在输出格式中解释。

第二行包含 n 个非负整数，为 a1,a2,…,an，即初始时 n 只蚯蚓的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。

#### 输出格式
第一行输出 ⌊m/t⌋ 个整数，按时间顺序，依次输出第 t 秒，第 2t 秒，第 3t 秒，……被切断蚯蚓（在被切断前）的长度。

第二行输出 ⌊(n+m)/t⌋ 个整数，输出 m 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 t，第 2t，第 3t，……的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。

即使某一行没有任何数需要输出，你也应输出一个空行。

请阅读样例来更好地理解这个格式。

#### 数据范围
1≤n≤105,
0≤ai≤108,
0<p<1,
0≤q≤200,
0≤m≤7∗106,
0<u<v≤109,
1≤t≤71
#### 输入样例：

    3 7 1 1 3 1
    3 3 2

#### 输出样例：

    3 4 4 4 5 5 6
    6 6 6 5 5 4 4 3 2 2

#### 样例解释
样例中，在神刀手到来前：3只蚯蚓的长度为3,3,2。

1秒后：一只长度为3的蚯蚓被切成了两只长度分别为1和2的蚯蚓，其余蚯蚓的长度增加了1。最终4只蚯蚓的长度分别为(1,2),4,3。 括号表示这个位置刚刚有一只蚯蚓被切断。

2秒后：一只长度为4的蚯蚓被切成了1和3。5只蚯蚓的长度分别为：2,3,(1,3),4。

3秒后：一只长度为4的蚯蚓被切断。6只蚯蚓的长度分别为：3,4,2,4,(1,3)。

4秒后：一只长度为4的蚯蚓被切断。7只蚯蚓的长度分别为：4,(1,3),3,5,2,4。

5秒后：一只长度为5的蚯蚓被切断。8只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。

6秒后：一只长度为5的蚯蚓被切断。9只蚯蚓的长度分别为：(1,4),3,5,5,2,5,4,6。

7秒后：一只长度为6的蚯蚓被切断。10只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。

所以，7秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,6。

7秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,2。

#### 分析

 - 详细分析见代码


#### 代码

```
/*
我们知道先切的蚯蚓是长度较长的,并且切掉的以后还会生长，
并且生长速度全部度一样，因此先切掉的左右部分一定大于后
切的左右部分,我们利用这个性质解题，用三个队列维护，
q1存初始化的所有蚯蚓，q2存切的蚯蚓的左部分，q3存切的蚯蚓的右部分
每次从这三个队首取值，取三个的最大值，一定是全部蚯蚓最大的。 
*/
#include <iostream>
#include <algorithm>
#include <queue>
#include <limits.h>
using namespace std;
const int N=100005;
queue<int> q1,q2,q3;
//q1存初始化的所有蚯蚓，q2存切的蚯蚓的左部分，q3存切的蚯蚓的右部分
int a[N]; 

int get_max(){//获取q1,q2,q3中的最大的蚯蚓长度，并将它出队 
	int ans=INT_MIN;
	if(!q1.empty()) ans=max(ans,q1.front());
	if(!q2.empty()) ans=max(ans,q2.front()); 
	if(!q3.empty()) ans=max(ans,q3.front());
	
	if(!q1.empty()&&ans==q1.front()) q1.pop();
	else if(!q2.empty()&&ans==q2.front()) q2.pop();
	else q3.pop();
	
	return ans;
}

int main()
{
	int n,m,q,u,v,t;
	cin>>n>>m>>q>>u>>v>>t;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);//排序，使得大的在队首那边 
	reverse(a,a+n);
	for(int i=0;i<n;i++){
		q1.push(a[i]);
	}
	
	int date=0;
	for(int i=1;i<=m;i++){
		int x=get_max();
		x+=date;
		int ft=x*1ll*u/v;
		int rt=x-ft;
		if(i%t==0) cout<<x<<" ";
		date+=q;
		q2.push(ft-date); // 减去date,是因为这个他之前没有生长 
		q3.push(rt-date); // 后面加上全部的会错误
	}
	cout<<endl;
	for(int i=1;i<=n+m;i++){ //按长度输出 
		int k=get_max(); 
		if(i%t==0) cout<<k+date<<" ";
	}
	return 0;
}
```

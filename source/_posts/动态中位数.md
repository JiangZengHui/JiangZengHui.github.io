---
title: 动态中位数
top: false
cover: false
toc: true
mathjax: true
date: 2019-07-30 19:19:16
password:
summary: 依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。
tags: 对顶堆
categories: 算法
---

#### 题目
依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。
#### 输入格式
第一行输入一个整数P，代表后面数据集的个数，接下来若干行输入各个数据集。
每个数据集的第一行首先输入一个代表数据集的编号的整数。
然后输入一个整数M，代表数据集中包含数据的个数，M一定为奇数，数据之间用空格隔开。
数据集的剩余行由数据集的数据构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。
#### 输出格式
对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。
数据集的剩余行由输出的中位数构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。

输出中不应该存在空行。
#### 数据范围
1≤P≤1000.
1≤M≤9999.
#### 输入样例 

    3 
    1 9 
    1 2 3 4 5 6 7 8 9 
    2 9 
    9 8 7 6 5 4 3 2 1 
    3 23 
    23 41 13 22 -3 24 -31 -11 -8 -7 
    3 5 103 211 -311 -45 -67 -73 -81 -99 
    -33 24 56
#### 输出样例

    1 5
    1 2 3 4 5
    2 5
    9 8 7 6 5
    3 12
    23 23 22 22 13 3 5 5 3 -3 
    -7 -3
#### 分析

 - 这个题我们可以用对顶堆来处理，即一个小根堆和一个大根堆来处理，大根堆存排序后的前1...i/2个，小根堆存排序后的后i/2+1...n个，这样的话小根堆的第一个一定是中位数。
 - 具体实现过程是读入第一个数假如小根堆，然后每读入一个数都跟小根堆的第一个数比较，大于等于的就加入小根堆，否则假如大根堆。
 - 每加入一个数后还要比较小根堆和大根堆的数目，小根堆的数目大于大根堆就将小根堆的第一个数移进大根堆，然后比较如果大根堆的数目大于小根堆，就将大根堆的第一个数移进小根堆，用这种办法来维护，大根堆存排序后的前1...i/2个，小根堆存排序后的后i/2+1...n个。
#### 代码：

```cpp 
#include <iostream>
#include <queue>
using namespace std;
int p,m,x,arr[10000],ans[10000];
int main()
{
	cin>>p;
	while(p--){	
		priority_queue<int> qued;
		priority_queue<int,vector<int>,greater<int> > quer;
		cin>>x>>m;
		cout<<x<<" "<<(m+1)/2<<endl;
		cin>>x;
		cout<<x<<" ";
		quer.push(x);
		for(int i=2;i<=m;i++){
			cin>>x;
			if(x>=quer.top()) quer.push(x);
			else qued.push(x);
			if(quer.size()>qued.size()){
				qued.push(quer.top());
				quer.pop();
			}
			if(qued.size()>quer.size()){
				quer.push(qued.top());
				qued.pop();
			}
			if(i&1) cout<<quer.top()<<" ";
			if(i%20==0) cout<<endl;
		}
		cout<<endl;
	}
	return 0;
} 
```

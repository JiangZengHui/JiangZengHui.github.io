---
title: 最近点对分治算法
top: false
cover: false
toc: true
mathjax: true
date: 2019-08-06 22:39:20
password:
summary: 最近点对分治算法模板
tags:
	- 最近点对
	- 模板
categories: 算法
---

#### 最近点对分治算法
对于平面上给定的N个点，给出所有点的坐标，即输入是平面上的N个点，输出是N点中具有最短距离的两点。
#### 分析

 - 这个问题我们有两种解决方案
 - 第一种就是直接暴力，对于每个点，遍历所有的点，求出他们的距离，最小的就是答案，但是这样时间复杂度无疑很大，至少是O(n^2)。
 - 第二种就是利用归并算法的思想进行二分，这样可以把时间复杂度降到O(nlogn)。
 - 现在我们主要来讨论第二种办法。
 - 对于n个点，我们可以将它们先按x轴为第1优先级y轴为第二优先级进行排序（当然你也可以反过来）。排序后，我们取中间点的x坐标为中心轴进行分半，小于他的在左边，大于他的在右边，如图：
 ![图1](1.png)
 - 中间点我们可以将它分到右半边（你也可以分到左边），然后对于左右两边，我们分别求出他们的最小距离ans1和ans2，然后取他们的最小值ans=min(ans1,ans2)就是答案，这么简单？，当然不可能，还有另一种情况没有考虑到，就是如果一个点在左边，一个点在右边有最小值怎么办，我们可以这样来算。
 - 当我们已经计算出左右两边的最小值了，那么如果左右各取一个点要达到比他还小的话，那么左右两点的离中间直线的距离肯定都不超过ans,因为如果超过的话，他到中间的距离都已经有ans，那么到左边某个点的距离肯定>=ans;即不可能小于ans，所以我们就可以将x坐标离中间直线距离超过ans的点全部去掉，如图：
 ![图2](2.png)
 
 - 然后我们还发现一个情况，就是当把一个点平移到中心轴的时候，只有另一边的点在以他为圆心，以ans为半径的范围内才可能有比ans小的距离的点，由于圆形难以判断，我们可以取如下图这样一个矩形。
 ![图3](3.png)
 
 - 对于那个点，只有矩形中的点跟他才有可能有小于ans的最近距离，我们将矩形均分为6部分，我们发现，对于那个点最多只有6个点可能在这个大矩形中，因为如果有7个点的话，那么肯定有两个点在同小矩形区域内(只有六个小矩形，有七个点，那么根据鸽笼定理，肯定会有两个点在同一个小矩形)，如果他们在同一个，那么他们最远距离肯定为小矩形的对角线：
 

```
maxdis=sqrt(2/3*r^2+1/2*r^2)<ans;     (r==ans)
```
 - 所以与前面矛盾(不可能左边的最小值大于这两点的距离);
 - 因此，对于某一边的每个点最多与另一边的六个点计算距离，这样就不需要与右边每个点计算，这样将大大降低时间。
 - 因为我们每次都二分了，当合并的时候我们可以用归并排序的思想，顺便将区间mid-ans至mid+ans的点按照y轴排序，这样对于每个点我们只需要计算他下面的点，或者上面的点，也将大大减少时间。
 ##### 例题可见：https://jzenghui.top/2019/09/05/xi-ji/
 ##### 具体函数代码如下(内含注释)：
#### 代码
```
double dis(node a,node b){//返回两点之间的距离 
	return sqrt(pow(abs(a.x-b.x),2)+pow(abs(a.y-b.y),2));
}
```

 

```
double solve(int l,int r){// 返回排序后下标l到r这个区间中最小点距
	//如果下标区间只有这一个点 返回最大值  
	if(l>=r) return INF;
	
	//递归二分，求两个左右区间的最小点距，并且将小的赋给ans存储 
	int mid=(l+r)>>1;
	double mid_x=opt[mid].x;
	double ans=min(solve(l,mid),solve(mid+1,r));
	
	//二分排序的合并过程  
	int left=l,right=mid+1,t=l;
	while(left<=mid && right<=r){
		if(opt[left].y<=opt[right].y) temp[t++]=opt[left++];
		else temp[t++]=opt[right++];
	}
	while(left<=mid) temp[t++]=opt[left++];
	while(right<=r) temp[t++]=opt[right++];
	for(int i=l;i<=r;i++){
		opt[i]=temp[i];
	}
	
	//从左到右将opt中的在mid_x-ans至mid_x+ans的点存进temp
	//这样temp中的点既是按y排序的，又是在mid_x-ans至mid_x+ans区间里的 
	int k=0;
	for(int i=l;i<=r;i++){
		if(opt[i].x>=mid_x-ans&&opt[i].x<=mid_x+ans){
			temp[k++]=opt[i];
		}
	}
	
	//从有序的temp数组中 找到每个点y坐标上面不超过ans的点的点距离求出
	//并且更新答案  
	for(int i=0;i<k;i++){
		for(int j=i-1;j>=0&&temp[i].y-temp[j].y<=ans;j--){
			ans=min(ans,dis(temp[i],temp[j]));
		}
	}
	
	//返回这个l到r下标的最小点距 
	return ans;
}
```

